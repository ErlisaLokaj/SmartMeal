@startuml ALL USE CASES
' =====================================================================
' SMARTMEAL - SEQUENCE DIAGRAMS (ALL USE CASES)
' =====================================================================
' Contains:
' 1. Manage Profile & Preferences
' 2. Manage Pantry
' 3. Search Recipes
' 4. View Recipe
' 5. Generate Weekly Meal Plan
' 6. Create Shopping List
' 7. On-demand Recommendations
' 8. Cook Recipe (Auto-Decrement)
' 9. Waste Logging & Insights
' 10. Save-me-first Suggestions
' =====================================================================

' ---------- (1) Manage Profile & Preferences ----------
@startuml Manage Profile & Preferences
title Manage Profile & Preferences (upsert semantics + diff updates)
autonumber
actor User
participant "Frontend" as FE
participant "Controller" as C
participant "ProfileService" as PS
database "PostgreSQL" as PG

User -> FE: Open Profile / Edit Preferences
FE -> C: PUT /users/{user_id} {goals, preferences, allergies, email?}
C -> C: validate payload (schema)
alt invalid
  C --> FE: 400 Bad Request
else valid
  C -> PS: upsert_profile(user_id, data)

  PS -> PG: begin transaction
  alt user exists
    PS -> PG: UPDATE app_user SET ... WHERE user_id = :id
  else create-on-PUT (if email provided)
    PS -> PG: INSERT app_user (user_id, email, ...)  -- create
  end
  PG --> PS: ok

  PS -> PG: SELECT user_preference[*] WHERE user_id = :id
  PG --> PS: existing_prefs
  PS -> PS: compute diff (inserts, updates, deletes)
  PS -> PG: INSERT/UPDATE/DELETE user_preference[*] (only diffs)
  PG --> PS: ok

  PS -> PG: SELECT user_allergy[*] WHERE user_id = :id
  PG --> PS: existing_allergies
  PS -> PS: compute diff (inserts, deletes)
  PS -> PG: INSERT/DELETE user_allergy[*]
  PG --> PS: ok

  PS -> PG: commit transaction
  PS --> C: (user, created_flag)
  alt created_flag == true
    C --> FE: 201 Created + Location: /users/{user_id} + profile
  else
    C --> FE: 200 OK + updated profile
  end
end
@enduml


' ---------- (2) Manage Pantry ----------
@startuml Manage Pantry
title Manage Pantry (Exception-Based Validation, Multi-User, No Fallbacks)
autonumber
actor User
participant "Frontend" as FE
participant "Controller" as C
participant "PantryService" as P
database "PostgreSQL" as PG
database "Neo4j" as NJ

== Add Single Item ==
User -> FE: Add pantry item {ingredient_id, qty, unit, best_before?}
FE -> C: POST /pantry {user_id, item}
C -> C: validate payload (Pydantic: quantity>0, unit)
alt invalid schema
  C --> FE: 422 Unprocessable Entity
else valid
  C -> P: add_item(user_id, item)
  
  P -> PG: verify user exists
  alt user not found
    PG --> P: no rows
    P --> C: NotFoundError
    C --> FE: 404 User Not Found
  else user exists
    PG --> P: user row
    
    P -> P: validate_ingredient_data(ingredient_id)
    P -> NJ: get_ingredient_meta(ingredient_id)
    note right of NJ: STRICT: No fake fallbacks!\nRaises exception if not found
    
    alt Neo4j not connected
      NJ --> P: RuntimeError("Neo4j driver not initialized")
      P --> C: ServiceValidationError("Invalid ingredient: Neo4j unavailable")
      C --> FE: 400 Bad Request (Neo4j unavailable)
    else ingredient not found
      NJ --> P: ValueError("Ingredient not found")
      P --> C: ServiceValidationError("Invalid ingredient: not found")
      C --> FE: 400 Bad Request (invalid ingredient)
    else ingredient found
      NJ --> P: {name, category, perishability, shelf_life_days}
      
      P -> P: if best_before missing -> estimate from shelf_life_days
      
      P -> PG: begin transaction
      P -> PG: SELECT pantry_item FOR UPDATE
      note right: Match by (user_id, ingredient_id, unit, **best_before**)\nBatch-level tracking: separate rows per expiry date
      alt row exists with SAME expiry date (merge batch)
        P -> PG: UPDATE pantry_item\nSET quantity = quantity + :qty
        note right: Same batch â†’ increment quantity
        PG --> P: updated row
      else row missing OR DIFFERENT expiry date (new batch)
        P -> PG: INSERT INTO pantry_item (...) VALUES (...)
        note right: Different batch â†’ create separate entry
        PG --> P: inserted row
      end
      P -> PG: commit transaction
      
      P --> C: PantryItem
      C --> FE: 201 Created + item
    end
  end
end

== Replace All Items (Bulk Update) ==
User -> FE: Update entire pantry {items[]}
FE -> C: PUT /pantry {user_id, items[]}
C -> C: validate payload (Pydantic)
alt invalid schema
  C --> FE: 422 Unprocessable Entity
else valid
  C -> P: set_pantry(user_id, items[])
  
  P -> PG: verify user exists
  alt user not found
    PG --> P: no rows
    P --> C: NotFoundError
    C --> FE: 404 User Not Found
  else user exists
    PG --> P: user row
    
    P -> P: extract all ingredient_ids from items[]
    P -> P: validate_ingredients_batch(ingredient_ids[])
    P -> NJ: get_ingredients_batch(ingredient_ids[])
    note right of NJ: Batch query - STRICT validation\nAll ingredients must exist\nNo fake fallbacks!
    
    alt Neo4j not connected
      NJ --> P: RuntimeError("Neo4j driver not initialized")
      P --> C: ServiceValidationError("Cannot validate ingredients: Neo4j unavailable")
      C --> FE: 400 Bad Request
    else any ingredient not found
      NJ --> P: ValueError("Ingredients not found: id1, id2, ...")
      P --> C: ServiceValidationError("Some ingredients not found")
      C --> FE: 400 Bad Request
    else all ingredients validated
      NJ --> P: ingredient_metadata_map {id: {name, category, shelf_life_days}}
      
      P -> PG: begin transaction
      P -> PG: DELETE FROM pantry_item WHERE user_id = :id
      note right: Atomic replace: delete all + insert new
      
      loop for each item in items[]
        P -> P: estimate best_before from metadata if missing
        P -> PG: INSERT INTO pantry_item (...)
        note right: Each item is a separate row\nSame ingredient with different expiry â†’ separate batches
      end
      
      P -> PG: commit transaction
      P --> C: PantryItem[]
      C --> FE: 200 OK + items[]
    end
  end
end

note over NJ
  **Neo4j Strict Mode**
  â€¢ No fake fallback data
  â€¢ Raises RuntimeError if not connected
  â€¢ Raises ValueError if ingredient missing
  â€¢ Batch queries for efficiency
  â€¢ Ensures data integrity
end note

note over P
  **Multi-User Support**
  â€¢ All operations scoped by user_id
  â€¢ User validation before pantry ops
  â€¢ Isolated pantry per user
end note

note over PG
  **Batch-Level Tracking**
  â€¢ Unique: (user_id, ingredient_id, unit, best_before)
  â€¢ Same ingredient with different expiry dates â†’ separate rows
  â€¢ Enables FIFO/FEFO inventory management
  â€¢ Example: 2L milk expires 2025-11-05 + 2L milk expires 2025-11-12
    â†’ stored as 2 separate pantry items
end note

== Update Quantity (Daily Use) ==
User -> FE: Consume/adjust pantry item {quantity_change, reason}
FE -> C: PATCH /pantry/{pantry_item_id}
C -> C: validate payload (Pydantic)
alt invalid
  C --> FE: 422 Unprocessable Entity
else valid
  C -> P: update_quantity(pantry_item_id, quantity_change, reason)
  
  P -> PG: SELECT pantry_item WHERE pantry_item_id = :id
  alt item not found
    PG --> P: no rows
    P --> C: NotFoundError
    C --> FE: 404 Pantry Item Not Found
  else item found
    PG --> P: pantry_item row
    P -> P: calculate new_qty = current_qty + quantity_change
    
    alt new_qty < 0
      P --> C: ServiceValidationError("Insufficient stock")
      C --> FE: 400 Bad Request (insufficient quantity)
    else new_qty == 0
      P -> PG: DELETE pantry_item WHERE pantry_item_id = :id
      note right: Auto-remove when quantity reaches exactly 0
      PG --> P: deleted
      P --> C: None (item deleted)
      C --> FE: 200 OK {status: "deleted", reason: "quantity_reached_zero"}
    else new_qty > 0
      P -> PG: UPDATE pantry_item SET quantity = :new_qty
      PG --> P: updated row
      P --> C: PantryItem (updated)
      C --> FE: 200 OK + updated item
    end
  end
end

== Get Expiring Soon (Waste Prevention) ==
User -> FE: Check what's expiring soon
FE -> C: GET /pantry/expiring-soon?user_id={id}&days={3}
C -> P: get_expiring_soon(user_id, days_threshold)

P -> PG: SELECT * FROM pantry_item\nWHERE user_id = :id\nAND best_before IS NOT NULL\nAND best_before <= (today + :days)\nORDER BY best_before ASC
note right: FIFO ordering - oldest first\nOnly items with expiry dates\nHelps prioritize cooking decisions

PG --> P: pantry_items[] (ordered by expiry)
P --> C: List[PantryItem]
C --> FE: expiring items (FIFO ordered)
@enduml


' ---------- (3) Search Recipes ----------
@startuml Search Recipes
title Search Recipes (with Error Handling & Allergy Filtering)
autonumber
actor User
participant "Frontend" as FE
participant "Controller" as C
participant "RecipeService" as RS
database "PostgreSQL" as PG
database "MongoDB" as MG

User -> FE: Search recipes {query, cuisine, include, exclude, user_id}
FE -> C: GET /recipes?q={query}&cuisine={cuisine}&user_id={id}...
C -> C: validate query parameters (Pydantic)
alt invalid parameters
  C --> FE: 422 Unprocessable Entity
else valid
  C -> RS: search_recipes(user_id, q, cuisine, limit, offset, include, exclude)
  
  alt user_id provided (allergy filtering)
    RS -> PG: get_user_allergy_ingredient_ids(user_id)
    PG --> RS: allergen_ingredient_ids[]
    note right: Get user's allergen IDs from user_allergy table
  end
  
  RS -> RS: build MongoDB query with filters:\n- Text search (title, ingredients.name)\n- Cuisine filter (ID or name)\n- Include/exclude ingredients\n- Exclude allergens ($nin)
  
  RS -> MG: _get_db()
  alt MongoDB not available
    MG --> RS: None
    RS -> RS: log warning
    RS --> C: [] (empty results)
    C --> FE: 200 OK + [] (graceful degradation)
  else MongoDB connected
    MG --> RS: database connection
    RS -> MG: recipes.find(query).skip(offset).limit(limit)
    MG --> RS: recipe documents[]
    
    RS -> RS: transform documents (_pub: _id â†’ id, add name)
    RS --> C: List[Recipe]
    C --> FE: 200 OK + recipes[]
  end
end

note over RS
  **Error Handling**
  â€¢ MongoDB unavailable â†’ empty results (graceful)
  â€¢ Query exceptions â†’ logged + empty results
  â€¢ No crashes on DB failures
end note

note over RS
  **Allergy Filtering**
  â€¢ Uses $nin operator for efficiency
  â€¢ Direct field query: "ingredients.ingredient_id": {"$nin": [...]}
  â€¢ Simpler than $not + $elemMatch
end note
@enduml


' ---------- (4) View Recipe ----------
@startuml View Recipe
title View Recipe (with ID Validation & Error Handling)
autonumber
actor User
participant "Frontend" as FE
participant "Controller" as C
participant "RecipeService" as RS
database "MongoDB" as MG

User -> FE: Open recipe details
FE -> C: GET /recipes/{recipe_id}
C -> C: validate recipe_id format (length check)
alt invalid format (empty or > 100 chars)
  C --> FE: 400 Bad Request (invalid ID format)
else valid format
  C -> RS: get_recipe_by_id(recipe_id)
  
  RS -> MG: _get_db()
  alt MongoDB not available
    MG --> RS: None
    RS -> RS: log warning
    RS --> C: None
    C --> FE: 404 Not Found (graceful degradation)
  else MongoDB connected
    MG --> RS: database connection
    
    RS -> RS: try to convert recipe_id to ObjectId
    alt conversion succeeds
      RS -> MG: recipes.findOne({"_id": ObjectId(recipe_id)})
    else conversion fails
      RS -> MG: recipes.findOne({"_id": recipe_id})
    end
    
    alt recipe found
      MG --> RS: recipe document
      RS -> RS: transform document (_pub: _id â†’ id, add name)
      RS --> C: Recipe
      C --> FE: 200 OK + recipe details
    else recipe not found
      MG --> RS: None
      RS --> C: None
      C --> FE: 404 Not Found
    end
  end
end

note over C
  **Input Validation**
  â€¢ Prevents injection attacks
  â€¢ Checks ID length < 100 chars
  â€¢ Rejects empty/invalid IDs
end note

note over RS
  **Error Handling**
  â€¢ MongoDB unavailable â†’ None (graceful)
  â€¢ Exceptions â†’ logged + None
  â€¢ Smart ID handling (ObjectId or string)
  â€¢ No crashes on DB failures
end note

note over RS
  **ID Flexibility**
  â€¢ Supports MongoDB ObjectId format
  â€¢ Supports UUID string format
  â€¢ Falls back gracefully if conversion fails
end note
@enduml


' ---------- (5) Generate Weekly Meal Plan ----------
@startuml Generate Weekly Meal Plan
title Generate Weekly Meal Plan (with substitutions)
autonumber
actor User
participant "Frontend" as FE
participant "Controller" as C
participant "PlannerService" as S
database "PostgreSQL" as PG
database "MongoDB" as MG
database "Neo4j" as NJ

User -> FE: Generate plan (week)
FE -> C: POST /plans
C -> S: generatePlan(userId, week)

S -> PG: getProfile + pantry
PG --> S: profile, pantry
S -> MG: searchRecipes(profile)
MG --> S: candidates

loop ingredients per candidate
  S -> NJ: checkConflicts(ingredient_ids)
  NJ --> S: conflicts
  alt conflicts
    S -> NJ: suggestSubstitutions(conflicting_id)
    NJ --> S: ranked substitutes
    S -> S: apply substitution
  end
end

S -> S: score by fit + pantry match
S -> PG: insert meal_plan + meal_entries
PG --> S: plan_id
S --> C: plan_id
C --> FE: Plan created
@enduml


' ---------- (6) Create Shopping List ----------
@startuml Create Shopping List
title Create Shopping List (Plan â†’ Pantry diff)
autonumber
actor User
participant "Frontend" as FE
participant "Controller" as C
participant "ShoppingService" as SH
database "PostgreSQL" as PG
database "MongoDB" as MG

User -> FE: Create shopping list for plan
FE -> C: POST /shopping-lists {plan_id}
C -> SH: buildList(plan_id, userId)

SH -> PG: load meal_entries(plan_id)
PG --> SH: entries (recipe_ids, servings)
SH -> MG: aggregateIngredients(recipe_ids, servings)
MG --> SH: consolidated ingredients
SH -> PG: loadPantry(userId)
PG --> SH: pantry

SH -> SH: compute missing = needs - pantry
SH -> PG: insert shopping_list + shopping_list_item[*]
PG --> SH: list_id
SH --> C: list_id
C --> FE: List ready
@enduml


' ---------- (7) On-demand Recommendations ----------
@startuml On-demand Recommendations
title On-demand Recommendations
autonumber
actor User
participant "Frontend" as FE
participant "Controller" as C
participant "RecommendationService" as R
database "PostgreSQL" as PG
database "MongoDB" as MG
database "Neo4j" as NJ

User -> FE: Open Home / Recommendations
FE -> C: GET /recommendations
C -> R: recommend(userId)

R -> PG: profile + pantry + recent cooking
PG --> R: data
R -> MG: candidateRecipes(by tags/cuisine/novelty)
MG --> R: candidates
R -> NJ: substitute/avoid checks (optional)
NJ --> R: scores

R -> R: rank (diversity, fit, novelty, pantry-usage)
R --> C: topK recipes
C --> FE: recommendations
@enduml


' ---------- (8) Cook Recipe (Auto-Decrement) ----------
@startuml Cook Recipe
title Cook Recipe â†’ Auto-decrement Pantry (with Validation & Feedback)
autonumber
actor User
participant "Frontend" as FE
participant "Controller" as C
participant "CookingService" as CS
participant "RecipeService" as RS
participant "PantryService" as PS
database "PostgreSQL" as PG
database "MongoDB" as MG
database "Neo4j" as NJ

== Mark Recipe as Cooked ==
User -> FE: Cook recipe {recipe_id, servings}
FE -> C: POST /cook {user_id, recipe_id, servings}
C -> C: validate payload (Pydantic: servings > 0)
alt invalid schema
  C --> FE: 422 Unprocessable Entity
else valid
  C -> CS: cook_recipe(user_id, recipe_id, servings)
  
  ' Step 1: User Validation
  CS -> PG: verify user exists
  alt user not found
    PG --> CS: no rows
    CS --> C: NotFoundError
    C --> FE: 404 User Not Found
  else user exists
    PG --> CS: user row
    
    ' Step 2: Recipe Retrieval
    CS -> RS: get_recipe_by_id(recipe_id)
    RS -> MG: _get_db()
    alt MongoDB not available
      MG --> RS: None
      RS --> CS: None
      CS --> C: ServiceValidationError("Recipe service unavailable")
      C --> FE: 503 Service Unavailable
    else MongoDB connected
      MG --> RS: database connection
      RS -> MG: recipes.findOne({"_id": recipe_id})
      alt recipe not found
        MG --> RS: None
        RS --> CS: None
        CS --> C: NotFoundError("Recipe not found")
        C --> FE: 404 Recipe Not Found
      else recipe found
        MG --> RS: recipe document
        RS --> CS: recipe {name, ingredients[], nutrition, cuisine, ...}
        
        ' Step 3: Recipe Validation (Allergies)
        CS -> PG: get_user_allergies(user_id)
        PG --> CS: allergen_ingredient_ids[]
        
        CS -> CS: check recipe ingredients against allergies
        alt recipe contains allergens
          CS --> C: ServiceValidationError("Recipe contains allergens: [ids]")
          C --> FE: 400 Bad Request (allergy conflict)
        else no allergen conflicts
          
          ' Step 4: Ingredient Batch Validation
          CS -> CS: extract unique ingredient_ids from recipe
          CS -> NJ: validate_ingredients_batch(ingredient_ids[])
          alt Neo4j not connected
            NJ --> CS: RuntimeError("Neo4j not initialized")
            CS --> C: ServiceValidationError("Cannot validate ingredients")
            C --> FE: 400 Bad Request (Neo4j unavailable)
          else all ingredients validated
            NJ --> CS: ingredient_metadata_map {id: {name, category, unit}}
            
            ' Step 5: STRICT Pantry Availability Check (BLOCKING)
            CS -> CS: _check_pantry_availability(recipe, servings)
            note right: **STRICT CHECK**\nRead-only validation\nBlocks cooking if ANY ingredient missing
            
            loop for each ingredient in recipe
              CS -> PG: SELECT * FROM pantry_item\nWHERE user_id = :user_id\nAND ingredient_id = :ingredient_id\nAND unit = :unit
              note right: Calculate total available stock
              
              PG --> CS: pantry_items[]
              CS -> CS: sum available quantities
              CS -> CS: compare with required quantity
              
              alt insufficient stock
                CS -> CS: add to shortages list:\n{ingredient_id, name, needed, available, deficit}
                note right: Track ALL shortages before failing
              end
            end
            
            alt ANY shortages detected
              CS --> C: ServiceValidationError(\n  "Cannot cook: Missing ingredients in pantry"\n  + list of shortages\n)
              C --> FE: 400 Bad Request\n{\n  "error": "Missing ingredients",\n  "shortages": [...],\n  "suggestion": "Generate shopping list first"\n}
              note right: **COOKING BLOCKED**\nUser must:\n1. Get shopping list\n2. Buy ingredients\n3. Add to pantry\n4. Then try cooking again
            else all ingredients available
              
              ' Step 6: Pantry Decrement (FIFO)
              CS -> PG: begin transaction
              
              CS -> CS: scale ingredient quantities by servings
              
              loop for each ingredient in recipe
                CS -> PG: SELECT * FROM pantry_item\nWHERE user_id = :user_id\nAND ingredient_id = :ingredient_id\nAND unit = :unit\nORDER BY best_before ASC\nFOR UPDATE
                note right: FIFO: consume oldest items first\nBatch-aware: handles multiple expiry dates
                
                PG --> CS: pantry_items[] (ordered by expiry)
                
                loop consume from pantry items (FIFO)
                  CS -> CS: calculate to_decrement = min(available, remaining_needed)
                  
                  alt item fully consumed
                    CS -> PG: DELETE pantry_item\nWHERE pantry_item_id = :id
                    note right: Auto-remove when quantity reaches 0
                    PG --> CS: deleted
                  else item partially consumed
                    CS -> PG: UPDATE pantry_item\nSET quantity = quantity - :to_decrement\nWHERE pantry_item_id = :id
                    PG --> CS: updated row
                  end
                end
              end
              
              ' Step 7: Cooking Log
              CS -> PG: INSERT INTO cooking_log\n(user_id, recipe_id, servings, cooked_at)\nVALUES (...)
              PG --> CS: cooking_log row
              
              CS -> PG: commit transaction
              
              ' Step 8: Generate Enhanced Response
              CS -> CS: build response with:\n- Recipe details (name, servings)\n- Pantry update status\n- Nutritional summary\n- Waste prevention tips\n- Personalized suggestions
              
              CS -> CS: calculate nutrition per serving from recipe data
              CS -> CS: generate contextual tips based on cuisine
              
              CS --> C: CookRecipeResponse {\n  success: true,\n  message: "Successfully cooked X for Y servings",\n  recipe_name,\n  servings,\n  pantry_updated: true,\n  shortages: [],\n  nutritional_summary: {calories, protein, carbs, fat},\n  waste_prevention_tips: [],\n  suggestions: []\n}
              
              C --> FE: 200 OK + cooking success
            end
          end
        end
      end
    end
  end
end

note over CS
  **STRICT COOKING POLICY**
  â€¢ MUST have ALL ingredients before cooking
  â€¢ Pre-check blocks cooking if any shortage
  â€¢ No partial cooking allowed
  â€¢ Forces proper planning workflow
end note

note over CS
  **Cooking Service Responsibilities**
  â€¢ User validation
  â€¢ Recipe retrieval & validation
  â€¢ Allergy conflict detection
  â€¢ Ingredient batch validation
  â€¢ FIFO pantry decrement
  â€¢ Cooking log creation
  â€¢ Enhanced response generation
end note

note over PG
  **FIFO Pantry Management**
  â€¢ ORDER BY best_before ASC (oldest first)
  â€¢ SELECT FOR UPDATE (transaction safety)
  â€¢ Auto-delete when quantity = 0
  â€¢ Batch-level tracking (separate rows per expiry)
  â€¢ Handles shortages gracefully
end note

note over CS
  **Error Handling**
  â€¢ Strict validation (no fake data)
  â€¢ Graceful degradation for service outages
  â€¢ Comprehensive error messages
  â€¢ Transaction rollback on failure
  â€¢ All validations before DB changes
end note

note over CS
  **Enhanced User Feedback**
  â€¢ Recipe name & details
  â€¢ Nutritional info per serving
  â€¢ Pantry shortage warnings
  â€¢ Waste prevention tips
  â€¢ Personalized suggestions
  â€¢ Shopping recommendations
end note

== Get Cooking History ==
User -> FE: View cooking history
FE -> C: GET /cook/history?user_id={id}&days={7}
C -> CS: get_cooking_history(user_id, days)

CS -> PG: SELECT * FROM cooking_log\nWHERE user_id = :user_id\nAND cooked_at >= (now() - :days)\nORDER BY cooked_at DESC
PG --> CS: cooking_logs[]

loop for each log
  CS -> MG: get_recipe_by_id(log.recipe_id)
  MG --> CS: recipe {name, cuisine}
  CS -> CS: enrich log with recipe details
end

CS --> C: CookingHistoryResponse[]
C --> FE: 200 OK + cooking history

== Generate Recipe Shopping List ==
User -> FE: Select recipe to cook
FE -> C: POST /cook/shopping-list {user_id, recipe_id, servings}
C -> CS: generate_recipe_shopping_list(user_id, recipe_id, servings)

CS -> PG: verify user exists
alt user not found
  PG --> CS: no rows
  CS --> C: NotFoundError
  C --> FE: 404 User Not Found
else user exists
  PG --> CS: user row
  
  CS -> MG: get_recipe_by_id(recipe_id)
  alt recipe not found
    MG --> CS: None
    CS --> C: NotFoundError
    C --> FE: 404 Recipe Not Found
  else recipe found
    MG --> CS: recipe {name, ingredients[]}
    
    CS -> NJ: validate_ingredients_batch(ingredient_ids[])
    NJ --> CS: ingredient_metadata_map
    
    CS -> CS: scale quantities by servings
    
    loop for each ingredient
      CS -> PG: SELECT * FROM pantry_item\nWHERE user_id = :user_id\nAND ingredient_id = :ingredient_id
      note right: Check current stock\n(read-only, no update)
      
      PG --> CS: pantry_items[]
      CS -> CS: sum available quantity
      CS -> CS: calculate: to_buy = needed - available
      
      alt available < needed
        CS -> CS: add to missing_items:\n{ingredient_id, name, needed,\navailable, to_buy, unit}
      end
    end
    
    CS -> CS: has_all = (missing_items.length == 0)
    CS -> CS: can_cook_now = has_all
    
    CS --> C: RecipeShoppingListResponse {\n  recipe_id, recipe_name, servings,\n  missing_items: [],\n  has_all_ingredients: bool,\n  total_items_needed: int,\n  can_cook_now: bool\n}
    
    alt has_all_ingredients == false
      C --> FE: 200 OK + shopping list
      note right: User must:\n1. Shop for missing items\n2. Add to pantry\n3. Then can cook
    else has_all_ingredients == true
      C --> FE: 200 OK + empty list
      note right: Can cook immediately!\nNo shopping needed
    end
  end
end

note over CS
  **Recipe Shopping List**
  â€¢ Pre-cooking planning tool
  â€¢ Shows what to buy
  â€¢ Read-only pantry check
  â€¢ Helps user prepare
  â€¢ Ensures cooking success
end note

@enduml



' ---------- (9) Waste Logging & Insights ----------
@startuml Waste Logging & Insights
title Waste Logging & Insights Dashboard
autonumber
actor User
participant "Frontend" as FE
participant "Controller" as C
participant "WasteService" as W
database "PostgreSQL" as PG
database "Neo4j" as NJ

== Log waste ==
User -> FE: Log waste {ingredient_id, qty, unit, reason, pantry_item_id?, auto_remove?}
FE -> C: POST /waste?user_id={id}
C -> C: validate schema (Pydantic)
alt invalid
  C --> FE: 400 Bad Request
else valid
  C -> W: validate_waste_data(ingredient_id, qty, unit)
  
  W -> W: check quantity > 0
  W -> W: normalize unit (lowercase, trim)
  W -> NJ: get_ingredient_meta(ingredient_id)
  note right of NJ: STRICT: No fake fallbacks!\nRaises exception if not found
  
  alt Neo4j not connected
    NJ --> W: RuntimeError("Neo4j driver not initialized")
    W --> C: ServiceValidationError("Invalid ingredient: Neo4j not connected")
    C --> FE: 400 Bad Request (Neo4j unavailable)
  else ingredient not found
    NJ --> W: ValueError("Ingredient not found in Neo4j")
    W --> C: ServiceValidationError("Invalid ingredient: not found")
    C --> FE: 400 Bad Request (invalid ingredient)
  else ingredient found
    NJ --> W: {id, name, category, perishability, proc_id}
    W --> C: validated_data {ingredient_id, qty, unit, category, name}
    
    C -> W: log_waste(user_id, validated_data)
    W -> PG: verify user exists
    alt user not found
      PG --> W: no rows
      W --> C: NotFoundError
      C --> FE: 404 User Not Found
    else user exists
      PG --> W: user row
      
      alt pantry_item_id provided AND auto_remove_from_pantry = true
        participant "PantryService" as P
        W -> P: update_quantity(pantry_item_id, -quantity, reason="waste")
        note right: Pantry Integration:\nDecrement wasted quantity from pantry
        
        alt pantry item not found
          P --> W: NotFoundError (pantry item missing)
          note right: Warning logged, continue with waste log
        else insufficient stock
          P --> W: ServiceValidationError (qty < 0)
          note right: Warning logged, continue with waste log\n(User may have already consumed it)
        else update successful
          P --> W: PantryItem (updated or deleted if qty=0)
          note right: Pantry synced with waste log!
        end
      end
      
      W -> PG: INSERT waste_log (user_id, ingredient_id, qty, unit, reason, occurred_at)
      PG --> W: waste_log row
      W --> C: WasteLogResponse
      C --> FE: 201 Created + waste_log
    end
  end
end

== Insights Dashboard ==
User -> FE: Open Waste Insights
FE -> C: GET /waste/insights?user_id={id}&horizon=30d
C -> W: build_insights(user_id, horizon)

W -> PG: verify user exists
alt user not found
  PG --> W: no rows
  W --> C: NotFoundError
  C --> FE: 404 User Not Found
else user exists
  PG --> W: user row
  
  W -> PG: SELECT * FROM waste_log\nWHERE user_id = :id AND occurred_at >= :start_date
  PG --> W: waste_logs[]
  
  alt no waste logs
    W --> C: empty insights (all zeros)
    C --> FE: insights view (no data message)
  else has waste logs
    W -> W: extract unique ingredient_ids from logs
    W -> NJ: get_ingredients_batch(ingredient_ids[])
    
    alt Neo4j not connected
      NJ --> W: RuntimeError("Neo4j driver not initialized")
      W --> C: ServiceValidationError("Cannot build insights: Neo4j unavailable")
      C --> FE: 400 Bad Request
    else any ingredient not found
      NJ --> W: ValueError("Ingredients not found: id1, id2, ...")
      W --> C: ServiceValidationError("Cannot build insights: missing ingredients")
      C --> FE: 400 Bad Request
    else all ingredients found
      NJ --> W: ingredient_metadata_map {id: {name, category, perishability}}
      
      W -> W: aggregate totals (count, quantity)
      W -> W: aggregate by ingredient (with name from Neo4j)
      W -> W: aggregate by category (from Neo4j metadata)
      W -> W: compute trends by week
      W -> W: aggregate by reason (top 5)
      W -> W: calculate percentages
      
      W --> C: WasteInsightsResponse {\n  total_count, total_qty,\n  most_wasted_ingredients[],\n  waste_by_category[],\n  waste_trends[],\n  common_reasons[]\n}
      C --> FE: insights view (charts/metrics)
    end
  end
end

@enduml


' ---------- (10) Save-me-first Suggestions ----------
@startuml Save-me-first Suggestions (Food Waste Prevention)
title Save-me-first Suggestions - Prevent Food Waste with Smart Recipe Recommendations
autonumber
actor User
participant "Frontend" as FE
participant "Controller" as C
participant "SaveMeFirstService" as SMF
participant "PantryService" as PS
participant "RecipeService" as RS
database "PostgreSQL" as PG
database "MongoDB" as MG
database "Neo4j" as NJ

== User Requests Waste Prevention Suggestions ==
User -> FE: Open Save-me-first dashboard
FE -> C: GET /save-me-first?days_threshold=3&max_suggestions=5
C -> C: validate query params (1-14 days, 1-20 suggestions)
alt invalid params
  C --> FE: 400 Bad Request {error details}
else valid
  C -> SMF: generate_suggestions(user_id, days_threshold, max_suggestions)
  
  == Step 1: Verify User ==
  SMF -> PG: SELECT * FROM app_user WHERE user_id = :id
  alt user not found
    PG --> SMF: no rows
    SMF --> C: NotFoundError
    C --> FE: 404 Not Found
  else user exists
    PG --> SMF: user data
    
    == Step 2: Get Expiring Pantry Items ==
    SMF -> PS: get_expiring_soon(user_id, days_threshold)
    PS -> PG: <<FIFO query>>\nSELECT * FROM pantry_item\nWHERE user_id = :id\nAND best_before BETWEEN NOW() AND NOW() + :days\nORDER BY best_before ASC
    PG --> PS: raw pantry items
    PS --> SMF: expiring_items_raw[]
    
    alt no expiring items
      SMF -> SMF: return empty response with general tips
      SMF --> C: SaveMeFirstResponse(total_expiring=0, tips=[general])
      C --> FE: 200 OK {no items, general tips}
    else has expiring items
      
      == Step 3: Enrich with Ingredient Metadata ==
      SMF -> SMF: extract ingredient_ids from pantry items
      SMF -> NJ: get_ingredients_batch([ingredient_ids])
      NJ -> NJ: MATCH (i:Ingredient)\nWHERE i.ingredient_id IN :ids\nRETURN i.ingredient_id, i.name, i.category
      NJ --> SMF: ingredient_metadata_map
      
      SMF -> SMF: for each pantry item:\n  - calculate days_until_expiry\n  - assign urgency_level:\n    * critical: < 1 day\n    * urgent: 1-2 days\n    * soon: > 2 days\n  - attach ingredient_name from metadata
      SMF -> SMF: sort by urgency, then days_until_expiry
      SMF -> SMF: count by urgency (critical_count, urgent_count)
      note right: ExpiringIngredient[] created
      
      == Step 4: Find Matching Recipes ==
      SMF -> PG: get_by_user_id(user_id) -- full pantry
      PG --> SMF: all_pantry_items[]
      SMF -> SMF: create pantry_ingredient_ids set
      
      ' Search strategy: prioritize by urgency
      SMF -> SMF: extract critical_ingredient_ids
      alt has critical ingredients
        SMF -> RS: search_recipes(user_id, include_ingredient_ids=critical_ids[:3])
        RS -> MG: db.recipes.find({ingredients.ingredient_id: {$in: critical_ids}})
        RS -> PG: check user allergies, preferences
        MG --> RS: recipes[]
        RS --> SMF: critical_recipes[]
      end
      
      SMF -> SMF: extract urgent + critical ingredient_ids
      alt need more recipes
        SMF -> RS: search_recipes(user_id, include_ingredient_ids=urgent_ids[:5])
        RS -> MG: db.recipes.find({ingredients.ingredient_id: {$in: urgent_ids}})
        MG --> RS: recipes[]
        RS --> SMF: urgent_recipes[]
      end
      
      alt still need more recipes
        SMF -> RS: search_recipes(user_id, include_ingredient_ids=all_expiring[:10])
        RS -> MG: db.recipes.find({ingredients.ingredient_id: {$in: expiring_ids}})
        MG --> RS: recipes[]
        RS --> SMF: more_recipes[]
      end
      
      == Step 5: Score and Rank Recipes ==
      SMF -> SMF: combine all recipes (deduplicate by recipe_id)
      
      loop for each recipe
        SMF -> SMF: extract recipe_ingredient_ids
        SMF -> SMF: calculate uses_expiring = recipe_ids âˆ© expiring_ids
        alt uses_expiring_count == 0
          SMF -> SMF: skip recipe (doesn't use expiring items)
        else uses expiring ingredients
          SMF -> SMF: calculate missing_ingredients = recipe_ids - pantry_ids
          SMF -> SMF: can_cook_now = (missing_count == 0)
          
          SMF -> SMF: calculate_match_score():\n  - base: (uses_expiring / total_ingredients) * 100\n  - bonus +20 if can_cook_now\n  - max 100
          
          SMF -> SMF: calculate_urgency_score():\n  - sum urgency weights for used ingredients:\n    * critical: 100 pts\n    * urgent: 60 pts\n    * soon: 30 pts\n  - average, max 100
          
          SMF -> SMF: estimate_effort(recipe):\n  - easy: <= 30 min, <= 7 ingredients\n  - medium: <= 60 min, <= 12 ingredients\n  - hard: otherwise
          
          SMF -> SMF: create RecipeSuggestion with scores
          note right: Stores recipe_id, name, cuisine,\ntotal_time, servings,\nuses_expiring_count,\nexpiring_ingredients_used[],\nmatch_score, urgency_score,\neffort_level, missing_count,\ncan_cook_now
        end
      end
      
      SMF -> SMF: sort recipes by:\n  1. Combined score (urgency * 0.6 + match * 0.4) DESC\n  2. can_cook_now first\n  3. missing_count ASC
      SMF -> SMF: take top max_suggestions recipes
      
      == Step 6: Generate Personalized Tips ==
      SMF -> SMF: generate_tips(expiring_ingredients, recipe_suggestions)
      alt has critical items
        SMF -> SMF: add urgent warning:\n  "âš ï¸ URGENT: {names} expiring today! Use or freeze."
      end
      
      alt has cookable recipes
        SMF -> SMF: add suggestion:\n  "âœ¨ You can cook '{recipe}' right now!"
      else has recipes but missing items
        SMF -> SMF: add suggestion:\n  "ðŸ“ Shop a few items to cook '{recipe}'"
      end
      
      alt many expiring items (>= 5)
        SMF -> SMF: add tip: "ðŸ’¡ Freeze items you can't use immediately"
      end
      
      alt no recipe matches
        SMF -> SMF: add tip: "ðŸ¥— Make a stir-fry or soup with expiring items"
      end
      
      SMF -> SMF: always add: "ðŸ“… Check pantry regularly"
      
      == Step 7: Return Response ==
      SMF -> SMF: create SaveMeFirstResponse:\n  - user_id\n  - generated_at (ISO timestamp)\n  - expiring_ingredients[]\n  - recipe_suggestions[]\n  - total_expiring\n  - critical_count, urgent_count\n  - tips[]
      
      SMF --> C: SaveMeFirstResponse
      C --> FE: 200 OK {\n  expiring_ingredients: [...],\n  recipe_suggestions: [...],\n  total_expiring: N,\n  critical_count: X,\n  urgent_count: Y,\n  tips: [...]\n}
    end
  end
end

== User Takes Action ==
alt user selects recipe
  User -> FE: Click "Cook This Recipe"
  FE -> C: redirect to /cook or /cook/shopping-list
  note right: Integrates with Use Case 8\n(Cook Recipe) or Recipe\nShopping List feature
else user dismisses
  User -> FE: Mark as "Not Interested" / Dismiss
  note right: Optional: could track\ndismissals for future\nranking improvements
else user freezes items
  User -> FE: Mark items as frozen
  FE -> C: PATCH /pantry/{item_id} {location: "freezer"}
  note right: Extends shelf life,\nremoves from expiring list
end

@enduml
